HTTP signatures provide a mechanism to digitally sign an HTTP message using either symmetric or asymmetric keys, such that it helps to both verify the identity of the sender and, verify that the message was not tampered during the transit.
The HTTP Signature specification [1] provides standardized mechanisms on how the client can include the digital signatures in the HTTP-based requests such that, in addition to ensuring end-to-end message integrity, it also authenticates the clients using the same approach instead of using multiple round trips. Also it eliminates the necessity to use shared secrets.
This specification presents two mechanisms to achieve following distinct purposes.
Authenticity: only dc2d2b169a2757e88ebcaa6be03670b0the clients thatcc3930f2523339a9a429be58177b439c has the private eb2eb03ed78c7aaa27e5c239e9d012efkey can send valid HTTP messages to the server
Message integrity: HTTP requests are protected from a ‘man in the middle attack’ where the messages 1b6b4513a61abad4b04ebd6f68496c1ecan get altered.
Purpose 1: For ensuring message integrity 613191ccabb90a152e68d86601acb958
The "Signature" scheme which is intended primarily to allow a sender to fe2c02e1efda887a875454786ddfc5c2 assert the contents of the stage fcde88a0f2451d8f87e34e2ea7a7b5bbmessage sent are correct and have not been altered during transmission or storage in a way that alters the meaning expressed in the original message as signed. Any party reading the message (the verifier) may independently confirm the validity of the message signature. This scheme is agnostic to the client/server direction and can be used to verify the contents of either HTTP requests, HTTP responses, or both.
Sample request on how the client e92337f1e0f4da4d434d6a5efc7a0462 can include Signature scheme with the request to enforce message integrity when calling an API.
